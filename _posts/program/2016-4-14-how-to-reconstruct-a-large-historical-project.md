---
layout: post
title: 如何重构一个大型历史项目——百度经验改版总结
category : program
tagline: "原创"
tags : [program]
keywords: [重构, 改版, 总结]
description: 本文将会介绍重构一个大型历史项目的方方面面
---
{% include JB/setup %}
挺长时间没写博客了，你以为我去玩了吗？其实我是去做了一个大项目，项目有多大呢？这么说吧，这个页面的pv有100000亿呢（概数），开场之前先来个热身吧，最近撸了一个小游戏《[看你有多色](http://yanhaijing.com/color/)》，源代码在[这里](https://github.com/yanhaijing/color)，欢迎大家交流。

项目做完后在内部做了次分享，本文就是这次分享的文字版，警告：本文略长，建议备好咖啡，来一段愉快的阅读之旅吧，我保证不会让你失望的。

本文将会介绍如何重构一个大型历史项目的方方面面。

本文将会按照下面的目录展开分享，本文仅讨论技术。

- 简介
- 准备
- 时间
- 团队
- 技术
- 架构
- 边界
- 收益
- 总结

## 简介
这次要改版的是[百度经验](http://jingyan.baidu.com/)最重要的页面之一——[经验wap详情页](http://jingyan.baidu.com/article/fdffd1f850e750f3e88ca169.html)，流量巨大，而且涉及到广告，就导致这必然是一个复杂的问题，而且这个页面已经有5年以上历史了，经手的人更是不胜枚举。

## 准备
项目上的准备就是PM提供的MRD和设计师提供的PSD，前端的准备基本是先熟悉旧版页面的逻辑，我本人其实也不熟悉这个页面。

## 时间
项目开始前肯定要给出排期，那么接下来就说排期和时间管理的问题。

### 预估时间
前端项目的时间预估最准确的就是从UE图预估，拿到UE图后将其拆分成各个组件，然后评估每个模块的开发时间，其实思想就是分治，将不可评估任务拆分成可评估任务。

这次的项目因为是就模块改版，还有一个维度就是看就模块老代码，这次老模块是一个X，工作量未知，所以留了一些buffer，结果还真派上了用场，在老代码里跌倒了几次。/(ㄒoㄒ)/~~

举个例子：

- 导航 2h
- 头部 3h
- 摘要 4h
- 。。。

这次我们评估的开发时间是8天，buffer是两个小时。

### 风险
这次遇到可能影响进度的风险点主要都是来自经验的老代码，历史数据结构，各种边界case。

有些东西，你不看老模块的代码是不可能知道的，所以还是要把老代码全部看懂才行。

### 实际时间
上面评估的时间是10天，最后我们两个人开发，开发时间改为每个人5天。

其中遇到了不少坑，最大的坑就是简版编辑器了，为了不影响进度，我们放弃了，将其放到二期中。

## 团队
这次开发并不是我单兵作战了，组织上给我配备了一个菜鸟，让我带着她做，o(╯□╰)o

### 合作
本次两个人一起开发，就涉及到如何合作的问题，在开始之前我制定了一些规则。

才学了语义化的提交信息，我准备尝试一下，我指定的规范在这里《[我的提交信息规范](http://yanhaijing.com/git/2016/02/17/my-commit-message/)》。

最后我们一共提交了127个commit，基本上等同意127个小功能，我们提倡勤提交，这样方便两个人同步进度。

因为页面被拆分成了模块，而我们的项目中支持模块化开发，所以两个人合作起来还是挺容易的，每个人负责自己的模块，互不干扰。

### 拆分
我们基本上是按照功能来进行拆分的项目，中间一砍，上面归我，下面归她。

### 效率
根据人月神话来说，团队人越多可能效率越低，那么如何保证两个人的效率和一个人时是一样的呢？我们有如下利器来保证：

- 模块化开发
- 良好的基础框架
- 合理的项目（功能）拆分

## 技术
接下来说说我们这次改版的技术细节吧。

### 指导原则
技术上大体可以分为以下几类：

- 新技术
- 陈旧技术
- 成熟技术
- 稳定技术

对于新技术我们还是持敬畏的态度，这次的选型就是选择成熟稳定的技术。 

### 技术栈
来说说我们这次的技术栈吧

- fis-plus
- sass
- <del>es6（新技术）</del>
- <del>promise（新技术）</del>
- template
- zepto，gmu
- lazyload

## 架构
架构是个最大的问题，我们从下面四个方面来说说：

- 目录
- 结构
- 样式
- 行为

### 目录
我们的目录规范就是fisp的目录规范，主要目录如下：

- page 模版文件
- test 测试数据
- widget 组成页面的组件

### 模版
我们用的是smarty模版，对应的就是结构——HTML，比如我们的模版文件是index.tpl，其内部有各个组件拼装而成。

模版可以继承，我们的业务模版都继承common模块的通用模版，这样的好处就是方便给所有页面添加通用的一些东西，比如百度统计等。

还可以在父模版挖一些坑，在自模版填，这个功能叫做block。

举个例子吧，比如如下图我们在父模版挖一个title的坑，因为每个页面的title可能都不一样。

![]({{BLOG_IMG}}287.jpg)

在子页面我们会向下面这样填坑

![]({{BLOG_IMG}}288.jpg)

再来说说widget，一般的一个页面会被拆分成一个个模块（组件），然后又每个模块去拼装页面。

举个例子，下面左边就是拆分完的页面，右边是伪代码。

![]({{BLOG_IMG}}289.png)

### 样式
这次改版我们的样式决定使用sass这个预处理器。

我们将样式精心分类，总共有一下三类：

- 公用css
- 组件css
- mixin

先来说说公用的css，其实mixin也可以算作公用的css，废话少说直接上代码。

![]({{BLOG_IMG}}290.png)

我们定义了两个mixin：

    @mixin clearfix() {
      &::after {
        content: "";
        display: table;
        clear: both;
      }
    }

    @mixin size($width, $height: $width) {
      width: $width;
      height: $height;
    }

_variables.scss里面我们只定义了几个能够抽取成公共的颜色变量

    // 主要颜色定义
    $color-muted: #aaabaa;
    $color-info: #666;
    $color-primary: #333;

再来说说组件样式，一个典型的组件大概有如下部分组成

![]({{BLOG_IMG}}291.png)

其中样式代码大概如下：

    @import "mixin";
    @import "variables";

    .wgt-step-read {
        background: $content-box-bg-color;
        a {
            color: $color-primary;
        }
        .arrow {
            @include size(5px, 9px);
            background: url(img/arrow.png?__sprite);
        }
    }

其编译后的css如下所示
    
    .wgt-step-read {background: #fff;}
    .wgt-step-read a {color: #333;}
    .wgt-step-read .arrow {width: 5px; height: 9px}

用了sass后我们可能会忽视嵌套问题，任意嵌套，我们规定嵌套不能超过三层。

**小贴士**：这里介绍一个css选择符的两种逻辑，我推荐的其实是中庸思想，不走极端。

    .wgt-step-read .arrow // 嵌套
    .wgt-step-read-arrow // 组合类名

    .wgt-step-read ul p span // bad
    .wgt-step-read .pv // 添加类名，解决上面嵌套层级的问题

再来说说我们样式的指导原则：

- wgt前缀（区分模块和其他类）
- 嵌套不要超过三层（添加类名解决）
- 合理使用类名（语义）
- 合理使用mixin（区分extend）
- DRY

最后说说布局之争，项目开始时我们有如下两种布局可以选择：

- px
- rem

最终我们选的还是传统的px，因为我们为我们是知识型页面，页面多为文字；其次px比rem更简单。

在我的逻辑看起来我用大屏是未来看到更多的文字，而不是更大的字体，如果我想看更大的字体我自己调整字体就好了。

### 行为

## 边界

## 收益

## 总结

## 附
本文的[百度脑图](http://naotu.baidu.com/file/5a45700dae2df3912c8587a8491b27fe?token=86b24083b15e144d)。



